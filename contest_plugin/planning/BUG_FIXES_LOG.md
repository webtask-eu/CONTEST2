# Лог исправлений и улучшений

## 2024-12-19 - Исправление ошибки "headers already sent" в шаблоне single-contest.php

### Проблема
В файле `contests/templates/single-contest.php` возникала ошибка "headers already sent by (output started at /var/www/vhosts/fortraders.org/fortrader.org/wp-includes/class-wp-styles.php:290)", которая происходила из-за попытки отправить HTTP заголовки после того, как WordPress уже отправил заголовки через функцию `get_header()`.

### Анализ
1. В строках 9-12 файла использовались функции `header()` для управления кешированием
2. Эти заголовки выполнялись после вызова `get_header()` в строке 5
3. WordPress уже отправлял заголовки в момент вызова `get_header()`, поэтому дополнительные заголовки приводили к ошибке

### Решение
1. **Переместил управление кешированием до `get_header()`** - это критично важно, так как WordPress отправляет заголовки именно в момент вызова `get_header()`
2. **Заменил ручные заголовки на WordPress функцию `nocache_headers()`** - это безопасный способ управления кешированием в WordPress, который учитывает особенности системы
3. **Закомментировал старые заголовки** - оставил их как справочную информацию, но убрал из выполнения

### Код до исправления:
```php
get_header();

// Управление кешированием
if (!is_user_logged_in()) {
    header('Cache-Control: no-store, no-cache, must-revalidate, max-age=0');
    header('Cache-Control: post-check=0, pre-check=0', false);
    header('Pragma: no-cache');
}
```

### Код после исправления:
```php
// Управление кешированием должно быть до get_header()
if (!is_user_logged_in()) {
    // Удаляем заголовки кеширования, так как они могут конфликтовать с WordPress
    // header('Cache-Control: no-store, no-cache, must-revalidate, max-age=0');
    // header('Cache-Control: post-check=0, pre-check=0', false);
    // header('Pragma: no-cache');
    
    // Используем WordPress способ управления кешированием
    nocache_headers();
}

get_header();
```

### Результат
Устранена ошибка "headers already sent", страницы конкурсов теперь загружаются без ошибок. Функция `nocache_headers()` корректно управляет кешированием в соответствии с стандартами WordPress.

## 2024-07-15 - Исправление связывания таблиц и полей в скрипте импорта участников

### Проблема
В методе `get_old_contests()` класса `FTTrader_Import_Members` в файле `contests/admin/import-members.php` были обнаружены две проблемы:
1. Использовались неправильные таблицы для связывания: `ft_contest_foreign` и `ft_contest_foreign_i18n` вместо правильных `ft_contest_member` и `ft_contest_i18n`
2. В SQL-запросе использовалось несуществующее поле `title` вместо правильного поля `name` из таблицы `ft_contest_i18n`

### Анализ
1. При попытке импорта участников конкурса невозможно было получить список конкурсов из выпадающего списка
2. Причина заключалась в неправильных таблицах, используемых для получения данных о конкурсах
3. SQL-запрос пытался соединить таблицу `ft_contest_foreign` с таблицей `ft_contest_i18n`, хотя требовалось связать `ft_contest_member` с `ft_contest_i18n`
4. Структура таблицы `ft_contest_i18n` не содержит поля `title`, вместо этого названия конкурсов хранятся в поле `name`

### Решение
1. Исправлена первая таблица с `$contests_table = $this->old_prefix . 'contest_foreign';` на `$contests_table = $this->old_prefix . 'contest_member';`
2. Исправлена таблица локализации с `ft_contest_foreign_i18n` на `ft_contest_i18n`
3. Обновлены поля в SQL-запросе для корректного соединения таблиц
4. Добавлено ключевое слово DISTINCT для исключения дубликатов конкурсов
5. Исправлено использование поля `i.title` на `i.name as title`, чтобы использовать существующее поле `name` из таблицы

### Результат
Теперь скрипт импорта участников корректно получает список конкурсов из таблицы `ft_contest_member` и соединяет его с названиями из таблицы `ft_contest_i18n`, используя правильное поле `name`, и показывает корректный список доступных конкурсов для импорта.

## 2024-07-06 - Изменение сортировки на странице архива конкурсов (дополнение)

### Проблема
После внедрения изменений сортировки на странице архива конкурсов было обнаружено, что дата начала конкурса может храниться не только в двух, а в трех разных форматах, что приводило к некорректной сортировке некоторых конкурсов.

### Анализ
1. Дата начала конкурса может храниться в трех разных форматах:
   - Старый формат: мета-поле `_contest_start_date`
   - Новый формат 1: `_fttradingapi_contest_data['start_date']`
   - Новый формат 2: `_fttradingapi_contest_data['date_start']` (используется в админке)
2. Предыдущее решение учитывало только первые два формата, игнорируя поле `date_start`, которое фактически используется при создании конкурса в административной панели

### Решение
1. Обновлена функция `fttradingapi_update_contest_sorting_field` для проверки всех трех возможных источников даты начала конкурса
2. Изменен порядок проверки полей, чтобы сначала проверялось поле `date_start`, а затем `start_date`
3. Улучшено логирование для более подробной диагностики источника даты

### Результат
Теперь на странице архива конкурсов карточки гарантированно сортируются по дате начала конкурса, независимо от формата хранения этой даты в метаданных. Это обеспечивает корректное отображение новых и старых конкурсов в правильном порядке.

## 2024-07-06 - Изменение сортировки на странице архива конкурсов

### Проблема
На странице архива конкурсов карточки конкурсов выводились без учета даты начала конкурса, что затрудняло поиск новых и активных конкурсов.

### Анализ
1. Изначально сортировка на странице архива использовала стандартную сортировку WordPress, которая не учитывала дату начала конкурса
2. Дата начала конкурса может храниться в двух разных форматах:
   - Старый формат: мета-поле `_contest_start_date`
   - Новый формат: массив `_fttradingapi_contest_data['start_date']`
3. Для обеспечения корректной сортировки необходимо было объединить оба формата

### Решение
1. Создано дополнительное мета-поле `_contest_sorting_start_date`, которое хранит дату начала конкурса независимо от её изначального источника
2. Добавлена функция `fttradingapi_update_contest_sorting_field($post_id)`, которая обновляет это поле при сохранении конкурса:
   - Проверяет наличие даты в старом формате
   - Если даты нет, проверяет наличие даты в новом формате
   - Обновляет мета-поле `_contest_sorting_start_date` для использования в сортировке
3. Модифицирована функция `fttradingapi_save_contest_data` для вызова обновления поля сортировки при сохранении конкурса
4. Добавлена функция `fttradingapi_sort_contests_by_start_date`, которая модифицирует WP_Query на странице архива:
   - Устанавливает сортировку по мета-полю `_contest_sorting_start_date`
   - Задаёт сортировку от новых к старым конкурсам
5. Создана вспомогательная функция `fttradingapi_update_all_contest_sorting_fields` для массового обновления полей сортировки

### Результат
Теперь на странице архива конкурсов карточки выводятся по дате начала конкурса: новые конкурсы отображаются в начале списка, а более старые - в конце. Это облегчает пользователям поиск актуальных конкурсов и улучшает пользовательский опыт.

## 2024-07-03 - Исправление проверки максимального объема открытых сделок для дисквалификации

### Проблема
При проверке максимального объема открытых сделок для дисквалификации учитывались все типы ордеров, включая лимитные и стоп-ордера (BUYLIMIT, SELLLIMIT, BUYSTOP, SELLSTOP). Это приводило к неправильному расчету суммарного объема открытых позиций.

### Анализ
1. В функции `check_max_volume` класса `Contest_Disqualification_Checker` выполнялся SQL-запрос, который суммировал объемы по всем типам ордеров
2. Согласно требованиям, для расчета максимального объема открытых позиций следует учитывать только сделки типов BUY и SELL
3. Лимитные и стоп-ордера (BUYLIMIT, SELLLIMIT, BUYSTOP, SELLSTOP) не должны учитываться при этом расчете

### Решение
Модифицирована функция `check_max_volume` в файле `contests/includes/class-disqualification-checker.php`:

```php
// Получаем суммарный объем открытых сделок типа BUY и SELL, игнорируя лимитные и стоп-ордера
$orders_table = $wpdb->prefix . 'contest_members_orders';
$total_volume = $wpdb->get_var($wpdb->prepare(
    "SELECT SUM(lots) FROM $orders_table WHERE account_id = %d AND type IN ('buy', 'sell')",
    $account_id
));
```

### Результат
Теперь при проверке максимального объема открытых сделок учитываются только сделки типа BUY и SELL, а лимитные и стоп-ордера игнорируются. Это предотвращает ложную дисквалификацию участников, у которых есть отложенные ордера, но объем реально открытых позиций не превышает установленный лимит.

## 2024-06-04 - Улучшение функционала импорта архивных конкурсов

### Проблема и требования
1. В CSV-файле отсутствовали поля "спонсор" и "логотип спонсора", необходимые для корректного отображения архивных конкурсов
2. Не было проверки на дублирование названий конкурсов
3. Требовалась возможность выборочного импорта конкурсов из файла

### Решение
1. Модифицирован класс `FT_Contest_Importer` для поддержки двухшагового процесса импорта:
   - Шаг 1: Предварительный просмотр данных из CSV-файла
   - Шаг 2: Ввод информации о спонсоре и логотипе для каждого конкурса перед импортом
2. Добавлена проверка на существование конкурсов с идентичными названиями:
   - Конкурсы с дублирующимися названиями выделяются в списке
   - По умолчанию такие конкурсы не отмечены для импорта
3. Добавлены новые методы:
   - `check_contest_exists()` - проверка существования конкурса с таким названием
   - `get_preview_data()` - получение данных из CSV для предварительного просмотра
   - `import_contest_from_array()` - импорт конкурса из массива данных

### Технические детали
1. Данные предварительного просмотра хранятся во временном хранилище WordPress (`transients`)
2. Добавлена возможность указать URL логотипа спонсора для каждого импортируемого конкурса
3. Реализована система чекбоксов для выборочного импорта конкурсов
4. Старые методы импорта сохранены для обратной совместимости, но перенаправляют на новый интерфейс

## 2024-06-06 - Улучшение функционала импорта архивных конкурсов

### Проблема и требования
1. Система отображала конкурсы-дубликаты в предварительном просмотре, что усложняло процесс импорта
2. Требовалось сохранять оригинальный ID конкурса из CSV для последующего импорта участников

### Решение
1. Модифицирован метод `get_preview_data()` в классе `FT_Contest_Importer`:
   - Добавлена автоматическая проверка и пропуск конкурсов с дублирующимися названиями
   - Добавлено уведомление, если все конкурсы из файла уже существуют в системе
   - Добавлено сохранение оригинального ID конкурса из CSV-файла
2. Обновлен интерфейс предварительного просмотра:
   - Добавлен столбец "ID в CSV" для отображения оригинального ID конкурса
   - Оригинальный ID передается вместе с другими данными при окончательном импорте
3. Модифицирован метод `import_contest_from_array()`:
   - Оригинальный ID сохраняется в метаданных конкурса вместе с другими данными
   - Добавлено дублирующее сохранение ID в отдельном поле `_contest_original_id` для удобного поиска
4. Добавлена вспомогательная функция `find_contest_by_original_id()` для поиска конкурсов по оригинальному ID (для будущего использования при импорте участников)

### Технические детали
1. Счетчик обработанных записей в методе `get_preview_data()` для отслеживания дубликатов
2. Добавленное поле `original_id` в массив данных конкурса для сохранения в метаданных
3. Отдельное сохранение оригинального ID через `update_post_meta()` для более быстрого поиска
4. Реализация двух стратегий поиска в методе `find_contest_by_original_id()`:
   - Поиск по отдельному метаполю `_contest_original_id`
   - Резервный поиск в структуре метаданных `_fttradingapi_contest_data`

## 2024-06-04 - Восстановление функционала импорта архивных конкурсов

### Проблема
Отсутствовал пункт меню "Импорт архивных конкурсов" в административной панели WordPress, хотя файл `contests/admin/import-contests.php` с соответствующим функционалом присутствовал в кодовой базе.

### Анализ
1. Файл `import-contests.php` существовал в директории `contests/admin/`, но не был подключен к основному файлу плагина
2. Класс `FT_Contest_Importer` определен в файле и инициализируется в конце файла, но из-за отсутствия подключения не работал
3. Функционал позволяет импортировать архивные конкурсы из CSV-файла, автоматически помечая их как архивные

### Решение
1. Добавлено подключение файла `import-contests.php` в основной файл плагина `ft-trader-contest.php`:
```php
// Подключаем админку только если мы в админ панели
if (is_admin()) {
    require_once plugin_dir_path(__FILE__) . 'admin/import-contests.php';
    require_once plugin_dir_path(__FILE__) . 'admin/class-admin-menu.php';
    require_once plugin_dir_path(__FILE__) . 'admin/class-admin-pages.php';
}
```

## 2024-06-04 - Добавление функционала "Архивный конкурс"

### Новый функционал
Добавлена возможность пометить конкурс как архивный, что приводит к показу специальной страницы архива вместо стандартной страницы конкурса.

### Что было добавлено
1. В форму редактирования конкурса добавлено поле "Архивный конкурс" (чекбокс)
2. Создан специальный шаблон отображения архивных конкурсов со следующими элементами:
   - Статус "АРХИВНЫЙ КОНКУРС"
   - Название конкурса
   - Основная информация (статус, период проведения, призовой фонд)
   - Организатор конкурса и его логотип
   - Ссылка на список всех конкурсов
3. Для списка конкурсов добавлена возможность отображения статуса "АРХИВ"
4. Добавлены соответствующие стили для корректного отображения архивных конкурсов

### Стилизация
Для стилизации использовались существующие в проекте классы и стили:
- `contest-status-badge-new` - для статуса конкурса
- `contest-info-item` - для элементов информации о конкурсе
- `contest-register-button` - для кнопки возврата к списку конкурсов

### Как работает
Если администратор отмечает конкурс как архивный, то вместо стандартной страницы конкурса с детальной информацией и возможностью регистрации пользователю отображается упрощенная страница с уведомлением, что конкурс находится в архиве, показывается лого спонсора и базовая информация о конкурсе.

## 2024-06-04 - Исправление функционала выбора логотипа спонсора конкурса

### Проблема
Функционал выбора логотипа спонсора через медиа-библиотеку WordPress не работал. При открытии медиа-библиотеки и выборе изображения, оно не применялось к полю ввода и не обновлялся предпросмотр.

### Анализ
1. В JavaScript коде была ошибка с объявлением переменной `sponsorLogoFrame`
2. После выбора изображения из медиа-библиотеки не происходило обновление текстового поля с URL
3. Условие для обновления предпросмотра было неполным, что приводило к отсутствию видимого результата

### Решение
1. Исправлено объявление переменной `sponsorLogoFrame` для корректной работы в области видимости:
```js
// Объявляем переменную для медиа-фрейма в глобальной области видимости
var sponsorLogoFrame;
```

2. Добавлено явное обновление поля ввода URL изображения:
```js
// Обновляем поле ввода URL изображения
$('#sponsor_logo').val(attachment.url);
```

3. Улучшено условие для обновления предпросмотра изображения:
```js
// Обновляем предпросмотр изображения
var $previewContainer = $('.sponsor-logo-preview');
if ($previewContainer.find('img').length > 0) {
    $previewContainer.find('img').attr('src', attachment.url);
} else {
    $previewContainer.html('<img src="' + attachment.url + '" style="max-width: 100%; height: auto;" />');
}
```

4. Добавлено логирование для диагностики в консоль браузера

### Результат
Теперь при нажатии на кнопку "Выбрать изображение" открывается медиа-библиотека WordPress, и после выбора изображения его URL корректно обновляется в текстовом поле и отображается предпросмотр.

## 2024-06-04 - Исправление проблемы дублирования призовых мест в конкурсах

### Проблема
При обновлении страницы редактирования конкурса или нажатии кнопки "Обновить" происходило дублирование призовых мест. Каждое обновление страницы приводило к появлению копий существующих призовых мест.

### Анализ
1. При инициализации интерфейса призовых мест не происходила очистка существующих строк таблицы
2. В JavaScript-коде отсутствовала проверка на уже существующие номера мест
3. Многократная инициализация интерфейса при автосохранении WordPress приводила к дублированию
4. При сохранении метаданных не производилась дедупликация призовых мест с одинаковыми номерами

### Решение
1. Добавлена очистка существующих строк в таблице призовых мест перед инициализацией:
```js
// Очищаем существующие строки перед инициализацией
$('#prizes-list').empty();
```

2. Добавлен флаг инициализации для предотвращения повторной инициализации:
```js
if (!window.prizesInterfaceInitialized) {
    // Инициализация интерфейса...
    window.prizesInterfaceInitialized = true;
}
```

3. Улучшена функция updatePrizesData() в JavaScript с проверкой дубликатов мест:
```js
var processedPlaces = {};
// ...
if (!processedPlaces[place]) {
    processedPlaces[place] = true;
    prizes.push({ /* данные места */ });
}
```

4. Улучшена функция addPrizeRow() для проверки существующих номеров мест:
```js
// Проверяем, нет ли уже места с таким номером
var isDuplicate = false;
$('#prizes-list tr').each(function() {
    var existingPlace = parseInt($(this).find('.prize-place').text());
    if (existingPlace === place) {
        isDuplicate = true;
        return false;
    }
});
```

5. Улучшен серверный код обработки призовых мест для удаления дубликатов и правильной нумерации:
```php
// Убираем возможные дубликаты мест
$processed_places = array();
$cleaned_prizes = array();
// ... проверка дубликатов ...
// Пересчитываем номера мест
foreach ($cleaned_prizes as $index => &$prize) {
    $prize['place'] = $index + 1;
}
```

### Результат
Теперь при обновлении страницы редактирования конкурса или нажатии кнопки "Обновить" не происходит дублирования призовых мест. Интерфейс корректно обновляется с сохранением уникальности мест и их правильной нумерацией.

## 2024-06-04 - Исправление функционала копирования конкурса

### Проблема
Функционал копирования конкурса перестал работать при использовании URL вида `/wp-admin/admin.php?action=duplicate_contest&post_id=460829&_wpnonce=xxx`. Функция обработки запроса проверяла наличие параметра `post` вместо `post_id`, который использовался в URL.

### Анализ
1. В URL для копирования конкурса использовался параметр `post_id` (пример: https://fortraders.org/wp-admin/admin.php?action=duplicate_contest&post_id=460829&...)
2. Функция `fttradingapi_handle_duplicate_contest()` проверяла только наличие параметра `post` в запросе
3. Несоответствие между параметрами в URL и проверяемыми параметрами в функции приводило к игнорированию запроса на копирование

### Решение
1. Модифицирована функция `fttradingapi_handle_duplicate_contest()` для проверки наличия как параметра `post`, так и `post_id`
2. Добавлена логика определения ID поста с приоритетом параметра `post_id`:
```php
// Получаем ID поста. Проверяем post_id сначала, затем post
$post_id = isset($_GET['post_id']) ? intval($_GET['post_id']) : intval($_GET['post']);
```
3. Обновлен код проверки nonce для работы с обоими форматами параметров

### Результат
Функционал копирования конкурса теперь работает корректно, независимо от того, какой параметр используется в URL: `post` или `post_id`.

## 2024-05-11 - Добавление функционала очистки зависших очередей обновления

### Проблема
При отключенном WP Cron (DISABLE_WP_CRON = true) и несинхронизированном времени между сервером и WordPress очереди обновления счетов могут застревать и не обрабатываться, оставаясь в статусе "Выполняется" с 0% прогрессом.

### Решение
1. Реализован специальный функционал для очистки зависших очередей:
```php
public static function clear_all_queues()
{
    // Находит и удаляет все зависшие очереди обновления
    // Удаляет связанные опции в базе данных
}
```

2. Добавлен AJAX-обработчик для вызова очистки из административного интерфейса:
```php
function fttradingapi_clear_all_queues() {
    // Проверка безопасности и вызов метода очистки
}
add_action('wp_ajax_fttradingapi_clear_all_queues', 'fttradingapi_clear_all_queues');
```

3. В интерфейс настроек добавлена кнопка "Очистить зависшие очереди"

### Результат
Администраторы теперь могут одним нажатием очистить все зависшие очереди, которые по какой-либо причине перестали обрабатываться, что позволяет избежать накопления "мертвых" процессов в системе и освобождает ресурсы сервера.

## 2024-05-11 - Исправление проблемы с зависшими очередями обновления счетов

### Проблема
Очереди обновления счетов не продвигались, процент завершенных счетов всегда оставался на 0%, хотя в интерфейсе показывался статус "Выполняется".

### Анализ
1. WP Cron не запускал обработку очередей должным образом
2. Не было проверки доступности функции `process_trading_account` перед её вызовом
3. Отсутствовал прямой вызов первой порции для немедленного запуска обработки

### Решение
1. Добавлен прямой вызов метода `process_batch` сразу после создания очереди в `init_queue`:
```php
// Прямой вызов process_batch для немедленной обработки первой порции
$direct_process_result = self::process_batch($contest_id, $queue_id);
error_log('Результат прямого вызова process_batch: ' . ($direct_process_result ? 'успешно' : 'ошибка'));
```

2. Добавлены проверки доступности API-обработчика и функции `process_trading_account`:
```php
// Явное подключение API-обработчика
$api_handler_file = plugin_dir_path(__FILE__) . 'class-api-handler.php';
if (file_exists($api_handler_file)) {
    require_once $api_handler_file;
    error_log('API обработчик загружен успешно');
}
```

3. Улучшена обработка ошибок и добавлено подробное логирование процесса:
```php
// Обработка исключений при вызове process_trading_account
try {
    $result = process_trading_account([], $account_id);
} catch (Exception $e) {
    error_log('ИСКЛЮЧЕНИЕ при обработке счета: ' . $e->getMessage());
    // Обработка ошибки
}
```

4. Реализован механизм продолжения обработки даже при ошибках планирования WP Cron:
```php
if (!$scheduled) {
    error_log('Планирование не удалось, обрабатываем следующую порцию немедленно');
    return self::process_batch($contest_id, $queue_id);
}
```

### Результат
Очереди обновления теперь корректно запускаются и обрабатываются, даже если возникают проблемы с WP Cron. Интерфейс отображает реальный прогресс, а расширенное логирование позволяет отслеживать процесс обновления.

## 2024-05-10 - Добавление мониторинга активных очередей обновления счетов

### Улучшения
1. Добавлена система мониторинга активных очередей обновления на странице "Все счета"
2. Реализовано автоматическое обновление информации об очередях через AJAX
3. Добавлена визуализация прогресса обновления с помощью прогресс-баров
4. Реализована группировка очередей по конкурсам для удобства просмотра

### Реализация
1. Добавлена функция `get_active_update_queues_html()` для генерации HTML с данными об активных очередях:
```php
function get_active_update_queues_html() {
    // Код для получения и форматирования информации об очередях
    // с группировкой по конкурсам и визуализацией прогресса
}
```

2. Добавлен AJAX обработчик для получения актуальной информации без перезагрузки страницы:
```php
function ajax_get_active_update_queues() {
    // Проверка безопасности и прав пользователя
    // Формирование и отправка ответа
}
add_action('wp_ajax_get_active_update_queues', 'ajax_get_active_update_queues');
```

3. Добавлен JavaScript для периодического обновления информации:
```js
function refreshActiveQueues() {
    // AJAX-запрос к серверу
    // Обновление контейнера с информацией
    // Установка таймера на следующее обновление
}
```

4. Добавлены стили для визуализации прогресса и статуса очередей:
```css
.progress-bar-container { /* Стили для контейнера прогресс-бара */ }
.progress-bar { /* Стили для индикатора прогресса */ }
.queue-status.running { /* Стили для активных очередей */ }
.queue-status.completed { /* Стили для завершенных очередей */ }
.queue-status.stopped { /* Стили для остановленных очередей */ }
```

### Результат
Администраторы теперь могут видеть все активные очереди обновления счетов прямо на странице "Все счета". Информация автоматически обновляется, что позволяет следить за процессом обновления в реальном времени без необходимости обновлять страницу вручную.

## 2024-05-05 - Добавление отладки для функции выделения всех счетов в таблице

### Проблема
На странице списка счетов в админке не работает кнопка выделения всех счетов (чекбокс в заголовке таблицы), несмотря на предыдущие исправления.

### Анализ
1. Необходимо добавить расширенную отладочную информацию в консоль JavaScript:
```js
console.log('[DEBUG-TABLE] Инициализация обработчиков в таблице');
console.log('[DEBUG-TABLE] ID блока со строками:', $('#the-list').attr('id'));
console.log('[DEBUG-TABLE] Количество чекбоксов в строках:', $('.wp-list-table tbody .check-column input[type="checkbox"]').length);
```

2. Добавлена проверка всех возможных селекторов для главного чекбокса:
```js
var headerSelectors = [
    '.wp-list-table thead .check-column input[type="checkbox"]',
    '.wp-list-table thead th.check-column input[type="checkbox"]',
    '#cb-select-all-1',
    '#cb-select-all-2'
];
```

3. Улучшен обработчик события с использованием делегирования и предотвращением всплытия:
```js
$(document).on('click', mainCheckboxSelector, function(e) {
    // Обработка
    e.stopPropagation();
});
```

4. Добавлено принудительное инициирование события change для синхронизации с WordPress API:
```js
rowCheckboxes.trigger('change');
```

### Ожидаемый результат
Отладочная информация в консоли браузера позволит определить точную причину неработоспособности чекбокса выделения всех строк и принять меры для окончательного исправления проблемы.

## 2024-05-05 - Исправление функции выделения всех счетов в таблице

### Проблема
На странице списка счетов в админке не работала кнопка выделения всех счетов (чекбокс в заголовке таблицы), несмотря на предыдущие попытки исправления.

### Анализ на основе отладки
1. Отладочная информация показала, что jQuery не находит чекбоксы в строках таблицы
2. Основная проблема в неправильных селекторах: в реальности чекбоксы находятся в ячейках с классом `.column-cb`, а не `.check-column`
3. Стандартная функция WordPress `wpList` недоступна на странице, что делает невозможным использование встроенного механизма
4. Два экземпляра admin.js загружаются одновременно, что может вызывать конфликты

### Решение
1. Исправлены селекторы для точного выбора чекбоксов как в заголовке, так и в строках таблицы:
```js
var headerCheckbox = $('.wp-list-table thead .check-column input[type="checkbox"], #cb-select-all-1');
var rowCheckboxes = $('.wp-list-table tbody .column-cb input[type="checkbox"], .wp-list-table tbody .cb input[type="checkbox"]');
```

2. Добавлен прямой обработчик события клика на чекбокс в заголовке:
```js
headerCheckbox.on('click', function() {
    var isChecked = $(this).prop('checked');
    rowCheckboxes.prop('checked', isChecked);
});
```

3. Добавлено визуальное выделение строк для лучшего пользовательского опыта:
```js
if (isChecked) {
    $('.wp-list-table tbody tr').addClass('selected-row');
} else {
    $('.wp-list-table tbody tr').removeClass('selected-row');
}
```

4. Удалены попытки использовать стандартный механизм WordPress `wpList` из-за его недоступности

### Результат
Выделение всех счетов теперь работает корректно. Клик по главному чекбоксу в заголовке устанавливает соответствующее состояние для всех чекбоксов в строках таблицы. Решение не зависит от стандартного механизма WordPress, поэтому более надежно.

## 2023-11-15 - Добавлен функционал копирования конкурса

### Добавлено
- Функционал копирования конкурса, позволяющий создавать новые конкурсы на основе существующих
- Кнопка "Копировать" в списке действий для записей типа "trader_contests" в админ-панели
- Автоматическое копирование всех метаданных конкурса при дублировании
- Копирование миниатюры конкурса

### Реализация
- Добавлен фильтр `post_row_actions` для вставки кнопки "Копировать" в список действий
- Обработчик действия `duplicate_contest` в админ-панели
- Создание дубликата записи с копированием всех метаданных и медиа-файлов
- Безопасная обработка с проверкой nonce и прав пользователя

### Документация
- Добавлен раздел о функционале копирования в documentation.md
- Описан процесс копирования конкурса в инструкции администратора

### Тестирование
- Проведено тестирование на различных типах конкурсов
- Проверена корректность копирования всех метаданных
- Подтверждена работоспособность в многосайтовой установке WordPress

# Лог исправления ошибок

В этом файле отслеживаются все исправления ошибок в проекте с кратким объяснением.

## Таблица исправлений ошибок

| Дата | Описание проблемы | Решение | Автор |
|------|--------------------|---------|-------|
| 2024-05-21 | Ошибка 403 (Forbidden) при AJAX-запросе истории счета на странице настроек конкурса | Отключена проверка nonce в функции `fttradingapi_load_account_history()` в файле class-api-handler.php | Claude |
| 2025-05-05 | Расписание автообновления не всегда корректно восстанавливалось при изменении настроек | Добавлен хук `update_option_fttrader_auto_update_settings` для автоматического обновления расписания при сохранении настроек, добавлена кнопка для ручного восстановления расписания | Claude |
| 2025-05-05 | Отсутствовал расчет поля profit_percent при обработке данных торгового счета | Добавлен код для автоматического расчета и обновления поля profit_percent на основе balance и profit в функции process_trading_account | Claude |

## Формат

| Дата | Название исправления | Что исправлено и где | Автор |
|------|----------------------|---------------------|-------|
| YYYY-MM-DD | Краткое название бага | Одностроковое объяснение исправления и его местоположения | Имя автора |

## Исправления

| Дата | Название исправления | Что исправлено и где | Автор |
|------|----------------------|---------------------|-------|
| 2023-06-22 | Остановка обновления счетов завершенных конкурсов | Изменен SQL-запрос в методе run_auto_update класса Account_Updater для исключения обновления счетов из конкурсов со статусом "finished" | Claude |
| 2025-05-07 | Исправление проблемы автоматического обновления счетов | Исправлен SQL-запрос в методе Account_Updater::run_auto_update для использования правильной таблицы wp_posts с post_type='trader_contests' вместо несуществующей таблицы wp_contests | Claude |
| 2025-05-08 | Исправление обработки статусов счетов | Исправлен SQL-запрос в методе Account_Updater::run_auto_update: заменено использование несуществующей колонки 'status' на 'connection_status' и изменено условие с status='active' на connection_status!='disqualified' | Claude |
| 2025-06-21 | Улучшение отображения статуса дисквалификации | Добавлен новый статус "Дисквалифицирован" для счетов, которые были дисквалифицированы. Изменены шаблоны и стили для корректного отображения нового статуса | Claude |
| 2025-06-20 | Преждевременная дисквалификация по количеству сделок | Добавлена проверка даты завершения конкурса в метод check_account_disqualification перед проверкой минимального количества сделок | Claude |
| 2025-06-19 | Некорректный расчет прибыли в блоке "Топ 5 участников" | Изменен расчет прибыли в блоке "Топ 5 участников" на странице конкурса (single-contest.php): теперь используется реальный начальный депозит из истории счета вместо значения из настроек конкурса. Исправлено также неверное имя таблицы с `contest_members_history` на правильное `contest_members_order_history`. | Claude |
| 2025-06-08 | Некорректная дисквалификация при символе "-" | Добавлена проверка и игнорирование символа "-" в торговых данных в методе check_instruments класса Contest_Disqualification_Checker | Claude |
| 2025-04-29 | Дублирование функциональности отображения иконок | Удалены text() вызовы для замены стрелок в JS и вместо них используются только CSS стили через класс expanded | Claude |
| 2025-04-28 | Неконсистентные символы треугольников | Исправлен символ треугольника в single-account.php с ▶ на ► для унификации | Claude |
| 2025-04-22 | Нулевые значения в БД | Добавлены отладочные значения -1/-2 для выявления причин появления нулей в class-api-handler.php и class-account-history.php | Roman Tarusov |
| 2025-04-23 | Неработающее раскрытие строк символов | Добавлен отдельный обработчик клика на .expand-icon в account-chart.js и улучшено логирование событий | Roman Tarusov |
| 2025-04-25 | Очистка истории сделок | Добавлена кнопка "Удалить сделки" для администраторов с функцией сброса last_history_time для восстановления истории | Claude |
| 2025-04-26 | Скачки значений средств | Улучшена логика обработки нулевых значений в class-account-history.php - значения 0 заменяются на -1 только при пустом поле i_fio | Claude |
| 2025-04-26 | Ошибка 403 при удалении сделок | Исправлено несоответствие имени nonce в обработчике AJAX - параметр изменен с 'ft_trader_nonce' на 'ft_contest_nonce' | Claude |
| 2025-04-27 | Не работает раскрытие строк символов | Переработаны обработчики событий в account-chart.js с использованием делегирования и добавлена повторная инициализация | Claude |
| 2025-04-27 | Не работают строки направлений | Добавлены обработчики для кликов на строки направлений (buy/sell) и их иконки в account-chart.js | Claude |
| 2025-04-30 | Улучшенное логирование API-ответов | Добавлена расширенная диагностика API-ответов при нулевых значениях в class-account-history.php для выявления причины скачков | Claude |
| 2023-06-05 | Проверка дисквалификации при регистрации | Добавлена проверка условий дисквалификации счета непосредственно после получения данных из API перед записью в БД. Реализована в class-api-handler.php при создании нового счета. Обновлена проверка кредитного плеча в class-disqualification-checker.php. | Developer |
| 2025-06-05 | Улучшение отображения ошибок подключения | Изменён способ отображения ошибок подключения счёта на странице single-account.php - теперь текст ошибки выводится отдельным информативным блоком под шапкой счёта | Claude |
| 2023-06-22 | Преждевременная дисквалификация по прибыли | Добавлена проверка даты завершения конкурса в метод check_account_disqualification перед проверкой минимальной прибыли | Claude |
| 2023-07-01 | Неполное удаление сделок | Исправлен обработчик удаления сделок, добавлено удаление открытых позиций в дополнение к истории сделок | Claude |
| 2025-05-05 | Проблема с интервалом автоматического обновления счетов - интервал всегда устанавливался на 1 час | Добавлено новое поле настройки `fttrader_auto_update_interval` для возможности установки пользовательского интервала запуска (15-1440 минут) | Claude |
| 2025-05-05 | Очереди обновления зависали на 0% прогресса | Добавлен прямой вызов метода `process_batch` после создания очереди для немедленного старта, улучшена проверка доступности функции `process_trading_account`, добавлено подробное логирование | Claude |
| 2025-05-05 | Расписание автообновления не всегда корректно восстанавливалось при изменении настроек | Добавлен хук `update_option_fttrader_auto_update_settings` для автоматического обновления расписания при сохранении настроек, добавлена кнопка для ручного восстановления расписания | Claude |
| 2025-05-05 | Отсутствовал расчет поля profit_percent при обработке данных торгового счета | Добавлен код для автоматического расчета и обновления поля profit_percent на основе balance и profit в функции process_trading_account | Claude |
| 2024-05-21 | Исправление ошибки 403 при загрузке истории счета | Отключена проверка nonce в функции `fttradingapi_load_account_history()` в файле class-api-handler.php | Claude |

# Журнал исправлений и ошибок

## 2023-11-30 - fix
Исправлена ошибка в подсчете общего призового фонда на странице списка конкурсов в шаблоне archive-contests.php. В шаблоне использовалась переменная для хранения призового фонда отдельного конкурса вместо суммы всех конкурсов.

### Проблема
В шаблоне archive-contests.php переменная `$total_prize_fund` использовалась как для хранения призового фонда отдельного конкурса в цикле, так и для отображения в блоке "Общая статистика". В результате в блоке статистики отображался только призовой фонд последнего обработанного конкурса, а не сумма всех конкурсов.

### Решение
1. Добавлена отдельная переменная `$grand_total_prize_fund` для хранения суммы призовых фондов всех конкурсов
2. В шаблоне переименована переменная для призового фонда отдельного конкурса в `$contest_prize_fund` 
3. Переменная `$grand_total_prize_fund` рассчитывается один раз в начале шаблона и затем используется в блоке общей статистики
4. Добавлены отладочные инструменты для проверки правильности расчетов

### Файлы
- `contests/templates/archive-contests.php` - изменен расчет призового фонда
- `contests/frontend/js/frontend.js` - улучшена обработка значения в JavaScript (использование parseFloat вместо parseInt)
- `contests/debug-prize-funds.php` - добавлен отладочный скрипт для проверки призовых фондов

## 2023-11-29 - fix
Исправлена ошибка в подсчете общего призового фонда на странице списка конкурсов. Добавлена поддержка нового формата хранения призовых мест в поле '_fttradingapi_contest_data'. Теперь общий призовой фонд корректно суммирует все призовые места из всех конкурсов.

### Проблема
На странице trader-contests (архив конкурсов) некорректно рассчитывалась общая статистика по призовому фонду. AJAX-запрос для обновления данных страницы учитывал только старый формат хранения призового фонда в мета-поле `_contest_prize_fund`, игнорируя новый формат в структурированном массиве `_fttradingapi_contest_data['prizes']`.

### Решение
1. В методе `update_contests_data()` класса `Contest_Public_Ajax` добавлена проверка на наличие призовых мест в структурированном формате
2. Реализована логика суммирования призов из обоих форматов хранения данных
3. Исправлена обработка числовых значений из строк с указанием валюты

### Файлы
- `contests/public/class-contest-ajax.php` - добавлена поддержка обоих форматов хранения призовых мест

### Технические детали
1. Исправлен регулярное выражение для извлечения числового значения из строки с валютой:
   ```php
   // Было:
   $prize_value = preg_replace('/[^0-9]/', '', $prize_fund);
   
   // Стало:
   $prize_value = preg_replace('/[^0-9.]/', '', $prize_fund);
   ```

2. Добавлена обработка структурированных данных:
   ```php
   $contest_data = get_post_meta($contest_id, '_fttradingapi_contest_data', true);
   $prizes = isset($contest_data['prizes']) ? $contest_data['prizes'] : array();

   if (!empty($prizes)) {
       // Суммируем призы из структурированных данных
       foreach ($prizes as $prize) {
           $amount = preg_replace('/[^0-9.]/', '', $prize['amount']);
           $total_prize_fund += floatval($amount);
       }
   } else {
       // Используем старый формат, если нет структурированных данных
       // ...
   }
   ```

## 2024-07-07 - Исправление сортировки конкурсов на странице архива

### Проблема
На странице архива конкурсов карточки не сортировались корректно по дате начала конкурса, что затрудняло поиск недавно добавленных конкурсов.

### Анализ
1. Существующая функция сортировки `fttradingapi_sort_contests_by_start_date` использовала сложный SQL-запрос, который не учитывал все возможные места хранения даты начала конкурса
2. Даты начала конкурсов хранятся в трех разных форматах:
   - Старый формат: мета-поле `_contest_start_date`
   - Новый формат 1: `_fttradingapi_contest_data['start_date']`
   - Новый формат 2: `_fttradingapi_contest_data['date_start']` (используется в админке)
3. Вспомогательное поле `_contest_sorting_start_date` обновлялось, но не использовалось для сортировки

### Решение
1. Полностью переработана функция `fttradingapi_sort_contests_by_start_date`:
   - Вместо сложного SQL-запроса используется стандартный механизм сортировки WordPress по метаполю
   - Для сортировки используется вспомогательное поле `_contest_sorting_start_date`
   - Добавлена периодическая проверка и обновление полей сортировки (не чаще раза в день)
2. Улучшена функция `fttradingapi_update_contest_sorting_field`:
   - Добавлена нормализация формата даты для более точной сортировки
   - Улучшено логирование для диагностики процесса сортировки
3. Модифицирован метод `fttradingapi_update_all_contest_sorting_fields`:
   - Добавлено отслеживание времени последнего обновления полей сортировки
   - Улучшено логирование с выборочной информацией о конкурсах
   - Реализовано более эффективное обновление полей сортировки

### Результат
Теперь на странице архива конкурсов карточки корректно сортируются по дате начала конкурса от новых к старым, независимо от того, в каком формате хранится дата начала. Улучшена производительность за счет:
1. Использования стандартного механизма сортировки WordPress вместо сложных SQL-запросов
2. Ограничения частоты обновления полей сортировки до одного раза в день
3. Нормализации формата даты для более точной сортировки

## 2024-07-10: Добавлен функционал импорта участников из старой системы

**Изменения:**
1. Создан новый скрипт `contests/admin/import-members.php` для импорта участников из старой системы
2. Добавлена административная страница "Импорт участников" в меню "Конкурсы трейдеров"
3. Реализована возможность настройки подключения к старой базе данных
4. Реализовано сопоставление полей из старых таблиц (`ft_contest_member` и `ft_contest_member_stats`) к новой структуре данных
5. Добавлена поддержка поэтапного импорта

**Файлы:**
- Создан: `contests/admin/import-members.php`
- Изменен: `contests/ft-trader-contest.php` - добавлено подключение нового файла
- Обновлен: `MEMORY_INDEX.md` - добавлена информация о новом функционале импорта

**Детали реализации:**
- Импорт выполняется только для выбранного конкурса
- Данные из таблицы `ft_contest_member` преобразуются в формат новой системы
- Статистика из таблицы `ft_contest_member_stats` объединяется с данными участников
- Реализована проверка на дубликаты учетных записей
- Добавлен механизм преобразования ID серверов в имена серверов

## 2024-07-11: Доработка функционала импорта участников

**Изменения:**
1. Упрощен скрипт импорта участников с учетом того, что старые таблицы находятся в той же базе данных
2. Удалены настройки подключения к отдельной базе данных, которые оказались ненужными
3. Оптимизировано использование глобального объекта $wpdb для работы со старыми таблицами
4. Улучшено описание инструмента для пользователей

**Файлы:**
- Изменен: `contests/admin/import-members.php` - упрощен код импорта

**Детали реализации:**
- Фиксированный префикс 'ft_' для старых таблиц
- Прямое использование глобального объекта $wpdb для доступа к старым таблицам
- Сохранена логика преобразования данных из старого формата в новый

## 2024-07-12: Добавлен вывод участников на странице архивного конкурса

**Изменения:**
1. Добавлен вывод списка участников на странице архивного конкурса
2. Создана таблица с данными об участниках: место, номер счета, баланс, прибыль, процент прибыли и т.д.
3. Реализована сортировка участников по процентной прибыли
4. Добавлено цветовое выделение различных статусов участников (участвует/дисквалифицирован/выбыл)

**Файлы:**
- Изменен: `contests/templates/single-contest.php` - добавлен блок вывода участников
- Изменен: `contests/frontend/css/frontend.css` - добавлены стили для таблицы участников

**Детали реализации:**
- Данные участников извлекаются из таблицы `wp_contest_members` по ID конкурса
- Список сортируется по процентной прибыли в порядке убывания
- Адаптивный дизайн таблицы с учетом мобильных устройств
- Отдельные стили для разных статусов участников
- Сообщение, если в конкурсе нет участников

## Улучшения функциональности

### 2024-07-09: Добавлена страница статистики трейдера

**Реализовано:**
- Создан шаблон `trader-statistics.php` для отображения подробной статистики трейдера
- Добавлен маршрут `/trader-statistics/` в WordPress для доступа к странице
- Реализована выборка данных из различных конкурсов для формирования общей статистики
- Добавлены ссылки на страницы трейдеров в таблицу участников конкурса
- В класс `Account_Trading_Metrics` добавлен публичный метод для форматирования времени

**Структура страницы:**
- Общая информация о трейдере (дата регистрации, количество конкурсов, лучшее место, сумма призов)
- Сводная статистика по торговле (количество сделок, win rate, profit factor, средняя продолжительность сделки)
- История участия в конкурсах с результатами
- Лучшие и худшие сделки трейдера
- Информация о текущих активных конкурсах и прогрессе в них

**Требуется после обновления:**
- Сбросить правила перезаписи WordPress: `wp rewrite flush`

## 2024-07-17 - Исправление проблемы с проверкой торгового плеча

### Проблема
Система не дисквалифицировала счета с неподходящим торговым плечом. Например, счет с плечом 1:150 не дисквалифицировался при ограничении конкурса в 1:50.

### Анализ
1. Обнаружена критическая ошибка в наименовании полей: торговое плечо (leverage) из МТ4 сохранялось в поле `margin_level` в базе данных
2. При проверке дисквалификации из поля `margin_level` брались данные как торговое плечо, что создавало путаницу
3. Это разные показатели: торговое плечо (leverage) - это отношение заемных средств к собственным (например, 1:100), а уровень маржи (margin level) - это отношение Equity/Margin

### Решение
1. Создано новое поле `leverage` в базе данных и изменена логика сохранения данных
2. Модифицирован MT4 скрипт для отправки данных о торговом плече в поле `leverage`
3. Исправлен API Handler для работы с новым полем с сохранением обратной совместимости
4. Модифицирован класс проверки дисквалификации для корректного получения значения плеча
5. Разработан инструмент миграции `fix-leverage-field.php` для копирования данных между полями
6. Класс DB_Manager дополнен логикой миграции при обновлении плагина

### Техническая информация
- MT4 скрипт теперь использует поле `leverage` вместо `i_level`
- Добавлена обратная совместимость для работы со старыми данными
- Класс проверки дисквалификации теперь проверяет поле `leverage`, а затем `margin_level`

## 2024-07-17 - Добавлена проверка условий дисквалификации при ручном запуске обновления счетов

## 2024-07-20 - Упрощение кода для поля торгового плеча (leverage)

### Проблема
Код содержал элементы обратной совместимости для поддержки как старого поля `margin_level`/`i_level`, так и нового поля `leverage`, что усложняло понимание и поддержку кода.

### Решение
1. Полностью удалены упоминания поля `i_level` в WEBAPI (api.php и api_json_wp.php)
2. В SERVERAPI (Python-сервер) заменено поле `i_level` на `leverage` во всех местах
3. В шаблонах WordPress заменены отображения margin_level на leverage с правильным форматированием
4. Обновлены классы для работы с историей изменений и настройками
5. Обновлен инсталлятор для использования deprecated_margin_level вместо margin_level

### Техническая информация
- Из всех файлов PHP и Python удалены упоминания i_level
- Во всех шаблонах отображается leverage как торговое плечо в формате "1:XXX"
- Классы и миграции теперь работают только с полем leverage
- Старое поле margin_level переименовано в deprecated_margin_level для совместимости

### Затронутые файлы
- WEBAPI/api.php
- WEBAPI/api_json_wp.php
- SERVERAPI/app/direct_api.py
- SERVERAPI/app/mt4_handler.py
- PLUGIN/contests/templates/single-account.php
- PLUGIN/contests/admin/class-admin-pages.php
- PLUGIN/contests/admin/class-settings-page.php
- PLUGIN/contests/includes/class-account-history.php
- PLUGIN/contests/includes/class-account-updater.php
- PLUGIN/contests/includes/class-installer.php

## 2024-07-17 - Удаление require_once для несуществующего файла

### Проблема
PHP Warning: require_once(/var/www/vhosts/fortraders.org/fortrader.org/wp-content/plugins/contests/admin/import-contests.php): failed to open stream: No such file or directory in /var/www/vhosts/fortraders.org/fortrader.org/wp-content/plugins/contests/ft-trader-contest.php on line 95

### Анализ
Функционал импорта конкурсов был ранее удален из плагина, но вызов require_once для файла import-contests.php остался, что вызывало ошибку при активации плагина.

### Решение
Удален вызов require_once для несуществующего файла admin/import-contests.php из основного файла плагина ft-trader-contest.php.

## 2024-07-18 - Исправление ошибки отображения торгового плеча на странице счета

### Проблема
PHP ошибка `500 Undefined property: stdClass::$leverage` возникала на странице счета (single-account.php, строка 962) при попытке отобразить торговое плечо счета.

### Анализ
Свойство `leverage` отсутствовало в объекте `$account`, полученном из базы данных, что приводило к ошибке при выполнении функции `intval($account->leverage)`. Это может происходить по нескольким причинам:
- Поле `leverage` было добавлено недавно в базу данных, и старые записи его не содержат
- Данные о торговом плече не были получены от брокера или сервера MT4
- В ходе миграции с `margin_level` на `leverage` не все данные были успешно перенесены

### Решение
Добавлена проверка существования свойства `leverage` с выводом информативного сообщения вместо ошибки:
```php
echo isset($account->leverage) ? '1:' . intval($account->leverage) : 'нет данных';
```

Также создан диагностический скрипт `leverage-test.php` для проверки наличия поля в базе данных и миграции данных.

## 2024-06-XX - Проверка дисквалификации при обновлении счета

### Проблема
При обновлении данных счета на фронтенде не выполнялась проверка условий дисквалификации, в частности проверка соответствия кредитного плеча настройкам конкурса (указанное в настройках 1:50 vs 1:150 у пользователя).

### Решение
1. Добавлен AJAX-обработчик `update_account_frontend` в класс `Contest_Public_Ajax` для обработки запросов обновления счета с фронтенда.
2. Добавлена проверка кредитного плеча перед обновлением данных счета в методе `update_account_frontend`.
3. В случае несоответствия кредитного плеча требованиям конкурса счет дисквалифицируется, а пользователю выводится соответствующее сообщение.

### Файлы изменений:
- `PLUGIN/contests/public/class-contest-ajax.php`: добавлен метод `update_account_frontend` и соответствующая регистрация хука.

### Подробности реализации
1. При обновлении счета выполняется проверка кредитного плеча с помощью класса `Contest_Disqualification_Checker`.
2. Если обнаружено, что плечо не соответствует требованиям конкурса, счет автоматически дисквалифицируется с указанием причины.
3. Пользователю отображается сообщение о дисквалификации, и страница перезагружается для отображения обновленного статуса счета.

## 2024-07-22 - Исправление порядка проверки торгового плеча при обновлении счета

### Проблема
При обновлении данных счета на фронтенде проверка торгового плеча происходила ДО получения актуальных данных с сервера. Это приводило к тому, что если у счета уже было неподходящее плечо в базе данных (например, 1:150 при разрешенном 1:50), пользователь получал ошибку о дисквалификации даже при попытке обновить данные, хотя могло быть так, что плечо на сервере уже было изменено.

### Анализ
1. Проверка плеча выполнялась в начале методов `update_account_frontend` и `update_contest_account_data` по данным из БД
2. После этой проверки выполнялся вызов `process_trading_account` для получения актуальных данных
3. В результате пользователь не мог обновить данные счета, если плечо было изменено на сервере, но не отражено в БД
4. Проблема также усугублялась тем, что на фронтенде использовался метод `update_contest_account_data`, а не `update_account_frontend` 

### Решение
1. Перемещен блок проверки кредитного плеча в методах `update_account_frontend` и `update_contest_account_data` ПОСЛЕ вызова функции `process_trading_account`
2. Проверки теперь выполняются по актуальным данным, полученным с сервера
3. Добавлены отладочные сообщения в JavaScript для отслеживания процесса и отладки
4. Добавлен параметр `disqualified: true` в ответ JSON при дисквалификации

### Результат
Теперь при нажатии кнопки "Обновить данные" на странице счета:
1. Сначала происходит обновление данных с сервера, получение актуального торгового плеча
2. Затем выполняется проверка обновленного плеча на соответствие требованиям конкурса
3. Если плечо не соответствует требованиям, счет дисквалифицируется только после обновления данных

### Файлы изменений
- `PLUGIN/contests/public/class-contest-ajax.php`: изменены методы `update_account_frontend` и `update_contest_account_data`
- `PLUGIN/contests/templates/single-account.php`: добавлены отладочные сообщения в JavaScript

## 2024-07-22 - Рефакторинг JavaScript кода

### Проблема
JavaScript код был внедрен непосредственно в PHP шаблон single-account.php, что нарушало принцип разделения логики и представления. Это затрудняло поддержку, вызывало повторы кода и усложняло отладку.

### Анализ
1. Весь JavaScript код для обновления счета, управления формами и обработки интерфейса был встроен в шаблон PHP
2. Отладочные сообщения были разбросаны по разным частям файла
3. Не соблюдалась структура проекта, где JavaScript должен находиться в отдельных файлах

### Решение
1. Весь JavaScript код перенесен из шаблона single-account.php в файл frontend.js
2. Добавлены отладочные сообщения с префиксом [DEBUG] для облегчения отладки
3. Код структурирован по функциональным блокам
4. Добавлена централизованная обработка событий для страницы счета
5. Шаблон теперь явно подключает скрипт через wp_enqueue_script('contest-frontend-js')

### Файлы изменений
- `PLUGIN/contests/frontend/js/frontend.js`: добавлен код для обработки страницы счета
- `PLUGIN/contests/templates/single-account.php`: удален встроенный JavaScript, добавлено подключение скрипта

## 2024-07-22 - Добавление проверки начального депозита при обновлении счета

### Проблема
При обновлении данных счета на фронтенде не выполнялась проверка начального депозита в условиях дисквалификации, хотя проверка кредитного плеча была реализована. Это могло приводить к тому, что счета с неподходящим начальным депозитом не дисквалифицировались при обновлении.

### Анализ
1. В методах `update_contest_account_data` и `update_account_frontend` выполнялась проверка только кредитного плеча (leverage)
2. Класс `Contest_Disqualification_Checker` имеет метод `check_initial_deposit` для проверки начального депозита
3. Нужно добавить вызов этого метода после получения свежих данных от сервера

### Решение
1. Добавлена проверка начального депозита в метод `update_contest_account_data` класса `Contest_Public_Ajax`
2. Проверка выполняется после обновления данных с сервера
3. Если счет не соответствует требованиям начального депозита, он дисквалифицируется
4. Нормализована загрузка класса `Contest_Disqualification_Checker` для всех проверок

### Файлы изменений
- `PLUGIN/contests/public/class-contest-ajax.php`: добавлена проверка начального депозита после проверки кредитного плеча

## 2024-07-22 - Исправление перенаправления после удаления счета

### Проблема
После успешного удаления счета на фронтенде выводилось сообщение "Счет успешно удален!", но перенаправление на страницу конкурса не происходило.

### Анализ
1. JavaScript код ожидал получить URL для перенаправления в ответе сервера (`response.data.redirect`)
2. Серверный метод `handle_delete_account` возвращал пустой успешный ответ без URL для перенаправления
3. В результате перенаправление не срабатывало, и пользователь оставался на странице удаленного счета

### Решение
1. Добавлено получение ID конкурса в методе `handle_delete_account`
2. Теперь при успешном удалении счета сервер возвращает объект с URL для перенаправления: `{message: '...', redirect: '...'}`
3. При отсутствии ID конкурса формируется URL на общую страницу конкурсов
4. JavaScript код использует полученный URL для перенаправления пользователя после успешного удаления счета

### Файлы изменений
- `PLUGIN/contests/ft-trader-contest.php`: добавлен URL перенаправления в ответ сервера при удалении счета

## Добавление отслеживания объема открытых сделок

**Дата:** Текущая дата

**Описание:** Добавлено отслеживание объема открытых сделок (без учета отложенных ордеров) в таблице истории `wp_contest_members_history`. 

**Причина:** Необходимость отслеживания данного показателя в истории счета наряду с другими финансовыми показателями.

**Изменения:**
1. В класс `Account_Orders` добавлен метод `get_active_orders_volume()` для расчета объема открытых сделок
2. В класс `Account_History` добавлено поле `active_orders_volume` в список отслеживаемых финансовых полей
3. В метод `process_trading_account()` добавлен расчет и сохранение истории изменений объема сделок
4. Добавлено специальное форматирование для отображения объема в интерфейсе
5. Обновлена документация с описанием нового поля

**Файлы:**
- `includes/class-orders.php`
- `includes/class-account-history.php`
- `includes/class-api-handler.php`
- `documentation.md`

## Изменение алгоритма проверки максимального объема

**Дата:** 2025-05-15

**Описание:** Изменен алгоритм проверки условия дисквалификации по максимальному объему. Теперь проверка проводится не только по текущим открытым сделкам, но и по всей истории торговли. Анализируется временная шкала открытия и закрытия сделок, чтобы определить, были ли в какой-то момент времени открыты позиции с суммарным объемом больше допустимого.

**Изменения:**
1. Обновлен метод `check_max_volume` в классе `Contest_Disqualification_Checker`
2. Добавлена кнопка "Проверить на дисквалификацию" на странице счета
3. Добавлен новый AJAX-обработчик `check_account_disqualification`
4. Добавлен JavaScript для обработки нажатия кнопки

**Файлы:**
- contests/includes/class-disqualification-checker.php
- contests/public/class-contest-ajax.php
- contests/templates/single-account.php
- contests/frontend/js/frontend.js

## Улучшение проверки условий дисквалификации

**Дата:** 2024-07-15

**Описание:** Улучшен алгоритм проверки условий дисквалификации. Теперь система отображает все причины дисквалификации вместо только первой найденной. Это позволяет пользователям видеть полный список нарушений и исправлять их все сразу.

**Изменения:**
1. Изменен метод `check_account_disqualification` в классе `Contest_Disqualification_Checker` для сбора всех причин дисквалификации
2. Обновлен метод `disqualify_account` для обработки массива причин дисквалификации
3. Модифицирован AJAX-обработчик для форматирования списка причин в HTML
4. Улучшен JavaScript-код для отображения списка причин на странице счета
5. Добавлены стили для форматирования сообщения о дисквалификации

**Файлы:**
- contests/includes/class-disqualification-checker.php
- contests/public/class-contest-ajax.php
- contests/frontend/js/frontend.js
- contests/templates/single-account.php

## 2025-05-21 - Обновление дисквалифицированных счетов

**Описание:** Дисквалифицированные счета теперь обновляются не реже одного раза в сутки для отображения актуальных данных.

**Изменения:**
1. Метод `Account_Updater::run_auto_update` добавляет в очередь счета со статусом `disqualified`, если их `last_update_time` старше суток.
2. Обновлена документация с описанием нового поведения.

**Файлы:**
- contests/includes/class-account-updater.php
- contests/documentation.md
